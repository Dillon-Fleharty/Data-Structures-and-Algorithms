Core Instruction Set  Name  Mnemonic  Format  Add  add  R  Add Immediate  addi  I  Add Imm. Unsigned  addiu  I  Add Unsigned  addu  R  And  and  R  And Immediate  andi  I  Branch On Equal  beq  I  Branch on Not Equal  bne  I  Jump  j  J  Jump and Link  jal  J  Jump Register  jr  R  Load Byte Unsigned  ibu  I  Load Halfword Unsigned  lhu  I  Load Linked  II  Load Upper Imm.  lui  I  Load Word  lw  I  Nor  nor  R  Or  or  R  Or Immediate  ori  I  Set Less Than  slt  R  Set Less Than Imm.  slti  I  Set Less Than Imm. Unsigned  sltiu  I  Set Less Than Unsigned  sltu  I  Shift Left Logical  sll  R  Shift Right Logical  srl  R  Store Byte  sb  I  Store Conditional  sc  I  Store Halfword  sh  I  Store Word  sw  I  Subtract  sub  I  Subtract Unsigned  subu  R  Arithmetic Core Instruction Set  Name  Mnemonic  Format  Branch On FP True  bclt  FI  Branch On FP False  bclf  Fi  Divide  div  R  Divide Unsigned  divu  R  FP Add Single  add.s  FR  FP Add Double  add.d  FR  FP Compare Single  c.x.s*  FR  FP Compare Double  c.x.d*  FR  FP Divide Single  div.s  FR  FP Divide Double FP Multiply Single FP Multiply Double FP Subtract Single FP Subtract Double Load FP Single Load FP Double Move From Hi Move From Lo Move From Control Multiply Multiply Unsigned Shift Right Ari th. Store FP Single Store FP Double div.d  FR  mul.s  FR  mul.d  FR  sub.s  FR  sub.d  FR  lwcl  I  ldcl  I  mfhi  R  mflo  R  mfcO  R  mult  R  multu  R  sra  R  swcl  I  sdcl  I  Operation R[rd] = R[rs] + R[rt] R[rt] = R[rs] + SignExtImm R[rt] = R[rs] + SignExtImm R[rd] = R[rs] + R[rt] R[rd] = R[rs] & R[rt] R[rt] = R[rs] & ZeroExtImm if(R[rs]==R[rt]) PC = PC + 4 + BranchAddr if(R[rs]!=R[rt]) PC = PC + 4 + BranchAddr PC = JumpAddr R[31] = PC + 8; PC = JumpAddr PC = R[rs] R[rt]={24'b0,M[R[rs] + SignExtlmm ](7 :0)} R[rt]={ 16'b0,M[R[rs] + SignExtlmm ]( 15 :0)} R[rt] = M[R[rs]+SignExtlmm] R[rt] = {imm, 16'b0} R[rt] = M[R[rs]+SignExtlmm] R[rd] = ~ (R[rs] I R[1t]) R[rd] = R[rs] I R[rt] R[rt] = R[rs] I ZeroExtlmm R[rd] = (R[rs] < R[rt])? 1 : 0 R[rt] = (R[rs] < SignExtlmm)? 1 : 0 (2) ahex R[rt] = (R[rs] < SignExtlmm) ? 1:0 R[rd] = (R[rs] < R[rt])? 1 : 0 R[rd] = R[rt] Ç shamt R[rd] = R[rt] >È shamt M[R[rs]+SignExtlmm](7:0) = R[rt](7:0) M[R[rs]+SignExtlmm] = R[rt]; R[rt] =(atomic)? 1 : 0 M[R[rs]+SignExtlmm](l5:0) = R[rt](l5:0) M[R[rs]+SignExtlmm] = R[rt] R[rd] = R[rs] -R[rt] R[rd] = R[rs] -R[rt] Operation if(FPcond)PC=PC+4+BranchAddr ( 4) if(!FPcond)PC=PC+4+BranchAddr( 4) Lo=R[rs]/R[rt]; Hi=R[rs].R[rt] Lo=R[rs]/R[rt]; Hi=R[rs].R[rt] F[fd ]= F[fs] + F[ft] {F[fd],F[fd+l]} = {F[fs],F[fs+l]} + {F[ft],F[ft+ 1]} FPcond = (F[fs] op F[ft])? 1 : 0 FPcond = ({F[fs],F[fs+l]} op {F[ft],F[ft+l]})? 1 : 0 F[fd] = F[fs] / F[ft] {F[fd],F[fd+l]} = {F[fs],F[fs+l]} / {F[ft],F[ft+ l ]} F[fd] = F[fs] * F[ft] {F[fd],F[fd+l]} = {F[fs],F[fs+l]} * {F[ft],F[ft+ l ]} F[fd]=F[fs] -F[ft] {F[fd],F[fd+l]} = {F[fs],F[fs+l]} -{F[ft],F[ft+1 ]} F[ 1t ]=M[R[ rs ]+SignExtlmm] F[rt]=M[R[rs]+SignExtlmm]; F[rt+ l ]=M[R[rs]+SignExtlmm+4] R[rd] = Hi R[rd] = Lo R[rd] = CR[rs] {Hi,Lo} = R[rs] * R[rt] {Hi,Lo} = R[rs] * R[rt] R[rd] = R[rt] È shamt M[R[rs]+SignExtlmm] = F[rt] M[R[rs]+SignExtlmm] = F[rt]; M[R[rs]+SignExtlmm+4] = F[rt+ l ] 