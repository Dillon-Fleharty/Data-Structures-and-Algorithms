Core Instruction Set,,,
Name,Mnemonic,Format,Operation
Add,add,R,R[rd] = R[rs] + R[rt]
Add Immediate ,addi,I,R[rt] = R[rs] + SignExtImm
Add Imm. Unsigned,addiu,I,R[rt] = R[rs] + SignExtImm
Add Unsigned,addu,R,R[rd] = R[rs] + R[rt]
And,and,R,R[rd] = R[rs] &  R[rt]
And Immediate,andi,I,R[rt] = R[rs] & ZeroExtImm
Branch On Equal,beq,I,if(R[rs]==R[rt]) PC = PC + 4 + BranchAddr
Branch on Not Equal,bne,I,if(R[rs]!=R[rt]) PC = PC + 4 + BranchAddr
Jump ,j ,J,PC = JumpAddr
Jump and Link,jal,J,R[31] = PC + 8; PC = JumpAddr
Jump Register,jr,R,PC = R[rs]
Load Byte Unsigned,ibu,I ,"R[rt]={24'b0,M[R[rs] + SignExtlmm ](7 :0)}"
Load Halfword Unsigned,lhu,I,"R[rt]={ 16'b0,M[R[rs] + SignExtlmm ]( 15 :0)}"
Load Linked,II,,R[rt] = M[R[rs]+SignExtlmm]
Load Upper Imm.,lui,I,"R[rt] = {imm, 16'b0}"
Load Word,lw,I,R[rt] = M[R[rs]+SignExtlmm]
Nor,nor,R,R[rd] = ~ (R[rs] I R[1t])
Or,or,R,R[rd] = R[rs] I R[rt]
Or Immediate,ori,I,R[rt] = R[rs] I ZeroExtlmm
Set Less Than,slt,R,R[rd] = (R[rs] < R[rt])? 1 : 0
Set Less Than Imm.,slti,I,R[rt] = (R[rs] < SignExtlmm)? 1 : 0 (2) ahex
Set Less Than Imm. Unsigned,sltiu,I ,R[rt] = (R[rs] < SignExtlmm) ? 1:0
Set Less Than Unsigned ,sltu,I,R[rd] = (R[rs] < R[rt])? 1 : 0
Shift Left Logical,sll,R,R[rd] = R[rt] « shamt
Shift Right Logical,srl,R,R[rd] = R[rt] >» shamt
Store Byte,sb,I,M[R[rs]+SignExtlmm](7:0) = R[rt](7:0)
Store Conditional,sc,I,M[R[rs]+SignExtlmm] = R[rt]; R[rt] =(atomic)? 1 : 0
Store Halfword,sh,I,M[R[rs]+SignExtlmm](l5:0) = R[rt](l5:0)
Store Word,sw,I,M[R[rs]+SignExtlmm] = R[rt]
Subtract,sub,I,R[rd] = R[rs] - R[rt]
Subtract Unsigned,subu,R,R[rd] = R[rs] - R[rt]
,,,
Arithmetic Core Instruction Set,,,
Name,Mnemonic,Format,Operation
Branch On FP True,bclt,FI,if(FPcond)PC=PC+4+BranchAddr ( 4)
Branch On FP False,bclf,Fi,if(!FPcond)PC=PC+4+BranchAddr( 4)
Divide,div,R,Lo=R[rs]/R[rt]; Hi=R[rs]¾R[rt]
Divide Unsigned,divu,R,Lo=R[rs]/R[rt]; Hi=R[rs]¾R[rt]
FP Add Single,add.s,FR,F[fd ]= F[fs] + F[ft]
FP Add Double,add.d,FR,"{F[fd],F[fd+l]} = {F[fs],F[fs+l]} + {F[ft],F[ft+ 1]}"
FP Compare Single,c.x.s*,FR,FPcond = (F[fs] op F[ft])? 1 : 0
FP Compare Double,c.x.d*,FR,"FPcond = ({F[fs],F[fs+l]} op {F[ft],F[ft+l]})? 1 : 0"
FP Divide Single,div.s,FR,F[fd] = F[fs] / F[ft]
FP Divide Double,div.d,FR,"{F[fd],F[fd+l]} = {F[fs],F[fs+l]} / {F[ft],F[ft+ l ]}"
FP Multiply Single,mul.s,FR,F[fd] = F[fs] * F[ft]
FP Multiply  Double,mul.d,FR,"{F[fd],F[fd+l]} = {F[fs],F[fs+l]} * {F[ft],F[ft+ l ]}"
FP Subtract Single,sub.s,FR,F[fd]=F[fs] - F[ft]
FP Subtract Double,sub.d,FR,"{F[fd],F[fd+l]} = {F[fs],F[fs+l]} - {F[ft],F[ft+1 ]}"
Load FP Single,lwcl,I,F[ 1t ]=M[R[ rs ]+SignExtlmm]
Load FP Double,ldcl,I,F[rt]=M[R[rs]+SignExtlmm]; F[rt+ l ]=M[R[rs]+SignExtlmm+4]
Move From Hi,mfhi,R,R[rd] = Hi
Move From Lo,mflo,R,R[rd] = Lo
Move From Control,mfcO,R,R[rd] = CR[rs]
Multiply,mult,R,"{Hi,Lo} = R[rs] * R[rt]"
Multiply Unsigned,multu,R,"{Hi,Lo} = R[rs] * R[rt]"
Shift Right Ari th.,sra,R,R[rd] = R[rt] » shamt
Store FP Single,swcl,I,M[R[rs]+SignExtlmm] = F[rt]
Store FP Double,sdcl,I,M[R[rs]+SignExtlmm] = F[rt]; M[R[rs]+SignExtlmm+4] = F[rt+ l ]